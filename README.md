به نام خدا

# آزمایش سوم آزمایشگاه مهندسی نرم‌افزار (TDD)
## مقدمات آزمایش
در این آزمایش ما به کمک روش TDD برنامه‌ی خود را پیاده‌سازی می‌کنیم. در نتیجه اول تست‌ها را طبق نیازمندی‌ها می‌نویسیم و سپس کد‌های مورد نیاز برای پاس کردن آن تست‌ها را می‌نویسیم.  به صورت کلی طبق صورت آزمایش، آزمایش ما از 3 بخش تشکیل شده مسئله که قسمت به قسمت پیش می‌رویم.
هر کدام از این 3 بخش را می‌توانید ببینید که در برنچ جداگانه‌ای زده شده‌اند و سپس با برنچ development مرج شدند. در نهایت نیز برنچ مستر ما protected
می‌باشد و با یک pull request از برنچ development به آن مرج می‌شود.
تمام نکات راجع به گیت و SOLID نیز در این آزمایش برآورده شده‌است. در زیر به شرح آزمایش می‌پزدازیم.
## شرح آزمایش
در مرحله‌ی اول می‌خواهیم برای مستطیل ویژگی‌های گفته شده را پیاده سازی کنیم. در نتیجه نخست تست مربوطه برای مساحت آن را می‌نویسیم که در زیر آن را می‌بینید. همانطور که می‌بینید تست‌ها کامپایل ارور می‌خورند چون هنوز کلاس‌ مربوطه را نداریم.

![1](https://github.com/aboots/SELab3/assets/59336942/d5c7b831-0d59-4562-8744-910d599f1ae8)

در قسمت بعد بر اساس تست‌های نوشته شده، کلاس مربوطه به مستطیل را می‌نویسیم. نخست متد area را به صورت صحیح پیاده‌سازی نمی‌کنیم! کد آن به شکل زیر می‌شود.

![2](https://github.com/aboots/SELab3/assets/59336942/9f69536c-b3a4-44e5-ae77-e10220d2ecb2)

حال همانطور که می‌بینید ارور‌های تست‌ها از کامپایل ارور به ران‌تایم ارور تبدیل می‌شوند.

![3](https://github.com/aboots/SELab3/assets/59336942/684eba1b-1fc0-428f-aa82-dd2e9cb7a739)

حال متد مساحت را به درستی پیاده‌سازی می‌کنیم و پس از آن همانطور که در زیر می‌بینید که تست ما به درستی اجرا می‌شود.

![4](https://github.com/aboots/SELab3/assets/59336942/3dafa418-d57c-4eff-a989-6665d9c0be30)

حال به سراغ مرحله‌ی دوم می‌روم. می‌خواهیم امکان تغییر ابعاد مستطیل را برای کاربر ایجاد کنیم. در نتیجه نخست تست‌های مربوطه را اضافه می‌کنیم برای getter و setterها که در زیر می‌بینید آن‌ها را.

![5](https://github.com/aboots/SELab3/assets/59336942/48d0787c-9443-49b7-8314-a521945ae304)

حال به سراغ پیاده‌سازی کد مربوطه برای این تست‌ها می‌رویم. متد‌های مربوطه را به شکل زیر اضافه می‌کنیم.

![6](https://github.com/aboots/SELab3/assets/59336942/bb58e810-06cb-4cb2-9a34-c01b31161ef2)

حال همانطور که در زیر می‌بینید تست‌ها دوباره با موفقیت اجرا می‌شوند. 

![7](https://github.com/aboots/SELab3/assets/59336942/0e987604-312e-4c27-ac16-ef57c2464bbc)

حال به سراغ مرحله‌ی سوم می‌رویم. طبق اصول SOLID درست نیست که مربع از مستطیل ارث‌بری کند چون ویژگی‌های مختلفی دارند و مثلا در مربع امکان این که طول و عرض متفاوت باشند وجود ندارد. پس برای اضافه کردن مربع نخست تست‌های آن را می‌نویسیم.

![8](https://github.com/aboots/SELab3/assets/59336942/61e68c2c-2184-43c3-b623-c046e45a71d4)

همانطور که می‌بینید تست‌ها پاس نمی‌شوند و دوباره کامپایل ارور می‌خوریم چون مربع نداریم.

![9](https://github.com/aboots/SELab3/assets/59336942/4dc2eff8-e227-45bc-9de9-a3e5d080254a)

حال کافی است تا نخست یک کلاس abstract برای shape درست کنیم که یک متد area دارد و هر دوی مربع و مستطیل از آن ارث‌بری کنند.

![10](https://github.com/aboots/SELab3/assets/59336942/b42f1eec-2783-4eea-bd66-757b1c3107cc)

حال کلاس square را می‌نویسیم و کلاس rectangle را طبق تعریف کلاس shape تغییر می‌دهیم. 

![11](https://github.com/aboots/SELab3/assets/59336942/fd2e3712-22c7-4013-bf6e-01700a217b92)

در نهایت همانطور که در زیر می‌بینید تمام تست‌هایمان با این تغییرات با موفقیت اجرا و پاس می‌شوند.

![12](https://github.com/aboots/SELab3/assets/59336942/7db8c5ec-e437-4aaf-92cc-0761cd9aad89)


## پرسش‌ها

1. در چرخه‌ی عمومی ایجاد نرم‌افزار، آزمون نرم‌افزار بعد از پیاده‌سازی نرم‌افزار انجام می‌شود، اما در روش TDD ابتدا unit test ها و سپس کد برنامه را می‌نویسیم. آیا این دو مورد با هم تناقضی دارند؟ در دو-سه خط توضیح دهید.

درست است که در چرخه‌ی عمومی ایجاد نرم‌افزار، آزمون نرم‌افزار بعد از پیاده‌سازی نرم‌افزار معمولا انجام می‌شود. اما TDD یک روش توسعه نرم‌افزار است (نه روش تست) که در آن ابتدا unit test ها نوشته می‌شوند و سپس کد برنامه. این دو مورد تناقضی با هم ندارند. در TDD، تست‌ها قبل از نوشتن کد نوشته می‌شوند تا برنامه‌نویس بتواند بر اساس آن‌ها کد خود را بنویسد. این روش به برنامه‌نویس کمک می‌کند تا با دید بازتر و راحت‌تری به مسئله نگاه کند و کد‌نویسی را سریع‌تر و کم‌هزینه‌تر  و به نوعی to the pointتر انجام دهد. و پس از آن نیز دوباره آزمون نرم‌افزار را هم داریم که مطمئن شویم همه چیز مطابق انتظارمان می‌باشد. پس این تست‌های مرحله اول به نوعی کمک به درست در نظر گرفتن نیازمندی‌ها و کمک در توسعه می‌باشد. در مقابل، در روش‌های عادی و سنتی، تست‌ها بعد از نوشتن کد نوشته می‌شوند که آن روش نیز مشکلی ندارد. این روش به ما این امکان را می‌دهد که از صحت کد خود با خبر شویم و با اطمینان آن را تحویل دهیم. پس این دو با هم تناقضی ندارند.

2. آزمون‌های واحد ریزدانه هستند. با بیان مثال، طیف آزمون‌ها بر اساس ریزدانگی یا درشت‌دانگی (granularity) را توضیح دهید.

طیف آزمون‌ها بر اساس ریزدانگی یا درشت‌دانگی (granularity) به این صورت است که unit tests در سمت ریزدانه‌ها قرار می‌گیرند. این آزمون‌ها معمولاً بر روی یک تابع یا متد خاص اجرا می‌شوند و هدف آن‌ها اطمینان از صحت عملکرد این بخش‌های کوچک از کد و توابع یا کلاس‌ها است. در سمت مقابل، آزمون‌های درشت‌دانگی مانند system tests یا acceptance tests قرار دارند که در این آزمون‌ها، کل سیستم یا بخش‌های بزرگتری از آن و تعامل آن‌ها تست می‌شوند. این آزمون‌ها به بررسی عملکرد کلی سیستم و تعامل بخش‌های مختلف آن با یکدیگر می‌پردازند. بنابراین، طیف آزمون‌ها از آزمون‌های ریزدانگی مانند آزمون‌های واحد شروع شده و به آزمون‌های درشت‌دانگی مانند آزمون‌های سیستمی و پذیرش ختم می‌شود. هر کدام از این آزمون‌ها نقش مهمی در تضمین کیفیت نرم‌افزار دارند. انواع آزمون‌های دیگر مثل Integration Test نیز وجود دارند که درشت دانه‌تر از unit tests می‌باشند. در واقع در تمام طیف‌ها انواع تست‌ها را داریم.

3. آیا همه‌ی انواع آزمون‌های نرم‌افزار را برنامه‌نویسان به‌وجود می‌آورند؟

خیر، همه‌ی انواع آزمون‌های نرم‌افزار را برنامه‌نویسان به‌وجود نمی‌آورند. برنامه‌نویسان معمولاً unit tests را می‌نویسند، اما در بسیاری از موارد، تیم  QA (تضمین کیفیت) و مدیران محصول نیز در نوشتن موارد آزمون شرکت می‌کنند. تیم QA معمولاً مسئول ارزیابی کیفیت نرم‌افزار و تضمین اینکه نرم‌افزار به درستی کار می‌کند می‌باشد. همچنین، در محیط‌های Agile، تحلیلگران کسب‌وکار ممکن است نیز در نوشتن موارد آزمون شرکت کنند. پس، نوشتن آزمون‌ها می‌تواند فرایندی تیمی باشد و نه فقط وظیفه‌ی برنامه‌نویسان. همچنین، برخی از آزمون‌های نرم‌افزاری می‌توانند توسط کاربران نهایی نیز انجام شوند.

4. اصول SOLID در کدام یک از گام‌های اصلی ایجاد نرم‌افزار (تحلیل نیازمندی‌ها، طراحی، پیاده‌سازی، آزمون و استقرار) استفاده می‌شوند؟ توضیح دهید.

اصول SOLID عمدتاً در گام طراحی از فرآیند توسعه نرم‌افزار استفاده می‌شوند. این اصول به برنامه‌نویسان کمک می‌کنند تا ساختار کلاس‌ها و روابط بین آن‌ها را مشخص کنند. همچنین، این اصول در نوشتن کدی که قابل نگهداری و توسعه است، مورد استفاده قرار می‌گیرند. با این حال، این اصول باید در زمان تحلیل کد و برقراری ارتباط بین کلاس‌ها در ذهن برنامه‌نویس باشد. در نهایت، این اصول در فاز پیاده‌سازی اجرا می‌شوند، اما این به این دلیل است که در فاز تحلیل و طراحی، این اصول را در نظر گرفته‌ایم. البته در مراحل دیگر هم به کار می‌رود و به نوعی در تمامی مراحل انگار وجود دارد. در طراحی و تحلیل را که ذکر کردیم. در گام آزمون، این اصول برای تضمین کیفیت کد و اطمینان از عملکرد صحیح نرم‌افزار به کار می‌روند. در گام استقرار، این اصول برای اطمینان از عملکرد صحیح نرم‌افزار در محیط‌های مختلف به کار می‌روند. به طور کلی در تمامی گام‌ها حواسمان به آن باید باشد و به کار می‌رود ولی بیشتر از همه در گام طراحی به کار می‌رود. 

5. فرض کنید در آزمایش بالا نیازی به تغییر ابعاد مستطیل نداشتیم. آیا در این حالت می‌توانستیم مربع را از مستطیل به ارث ببریم؟ توضیح دهید.

خیر، باز هم درست نبود که این کار را انجام دهیم. البته که می‌شد این کار را کرد و کد درست هم کار کند ولی خب اصول SOLID را این گونه زیر پا می‌گذاریم و دیگر برنامه‌ی ما برای مثال OCP را ندارد. چون دیگر با اضافه کردن نیازمندی‌ها دچار مشکل می‌شویم و دیگر نمی‌توانیم به درستی develop کنیم. از لحاظ مفهومی هم مشکل دارد و مثلا نمی‌توان مربعی داشت که طول و عرض یکی نداشته باشند ولی در مستطیل این اجازه وجود دارد. اگر بخواهیم بعدا چیزی به کد اضافه کنیم ممکن است دوباره این طراحی ارث‌بری نادرست برایمان مشکل‌ساز شود. پس به طور کلی این کار درست نیست.
